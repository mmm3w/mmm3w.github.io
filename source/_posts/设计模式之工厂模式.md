### 工厂模式

##### 个人理解

工厂方法用来处理对象的创建，该内容出现的地方可以是单独的对象、子类的具体实现

-   简单工厂：对创建对象的代码进行封装，形成一个工厂类。（严格意义上是一种编程习惯）
-   工厂方法：包含抽象的工厂类以及该抽象的实现类，由实现类决定最后创建的对象是什么。在创建对象中，相同的部分在抽象类中，不同的部分有抽象方法+实现类决定。**_重点在继承_**

    > 通过子类来创建对象，客户只需要知道所使用的抽象类型，子类决定具体类型，只负责将客户端从具体实现中解耦。
    > 把对象的创建委托给子类，子类实现工厂方法来创建对象

-   抽象工厂：用抽象接口类代替原来的工厂方法中的抽象基类，(实现类或许能够对多个接口进行实现组合)。**_重点在对象组合_**

    > 提供一个用来创建一个产品家族的抽象类型，该类型的子类定义了产品被生产的方法。如果想使用，必须先实例化，然后将它传入针对抽象所写的代码中，如果需要扩展，那就要修改接口。
    > 对象的创建被实现在工厂接口暴露出来的方法中

_相比工厂方法的创建一个产品，抽象工厂是创建一个产品家族，这一点不是很懂（所谓产品家族就是多种不同的具体实现对象？这么说工厂方法就是一条流水线，抽象工厂就是多条流水线，工厂根据条件一次只能生产一种，抽象工厂根据条件一次能够生产多种。上衣工厂根据条件生产某种上衣，服装抽象工厂能够根据条件生产一套衣服，这样的感觉？）_

##### 示例代码

-   简单工厂

```java
class Product {
  String name;
  void output(){
    sout(name);
  }
}

class ProductOne extends Product{
  ProductOne(){
    name = "ProductOne";
  }
}

class ProductTwo extends Product{
  ProductOne(){
    name = "ProductTwo";
  }
}

//对创建对象的代码进行封装
Product createObj(String type){
  Product obj = null;
  if (type.equals("one")) {
    obj = new ProductOne();
  }else if (type.equals("two")) {
    obj = new ProductTwo();
  }
  return obj;
}

//最后调用
void test(String type){
  Product obj;
  obj = createObj(type);
  obj.output();
}
```

-   工厂方法

```java
abstract class Product {
  String name;
  void output(){
    sout(name);
  }
}

class ProductOne extends Product{
  ProductOne(String from){
    name = "ProductOne from " + from;
  }
}

class ProductTwo extends Product{
  ProductOne(String from){
    name = "ProductTwo from " + from;
  }
}

//抽象出来的工厂,实现了所有操作产品的方法
//但没有实现生产方法
abstract class Creator{
  //该类包含一些固定的不允许改变的操作未列出
  ....

  //不同的地方使用抽象方法，具体实现交由子类
  abstract Product createObj();
}

class CreatorOne extends Creator{
    Product createObj(){
      //根据type自己的一套生产
      //这里可以对产品融入一些自己工厂的特色
      return new ProductOne("CreatorOne");
    }
}

class CreatorTwo extends Creator{
    Product createObj(){
      //根据type自己的一套生产
      //这里可以对产品融入一些自己工厂的特色
      return new ProductTwo("CreatorTwo");
    }
}

void test(){
  //此时就要先实例化一个工厂对象，再根据type生产对象
  Creator one = new CreatorOne();
  Creator two = new CreatorTwo();
  Product product = one.createObj();
  product.output();
  product = two.createObj();
  product.output();
}
```

-   抽象工厂

```java
//组件
abstract class Product {
  String part1;
  String part2;
  String part3;

  void output(){
    sout(part1 + part2 + part3);
  }

  abstract void createPart();
}

class ProductOne extends Product{
  Creator mCreator;
  ProductOne(Creator creator){
    mCreator = creator;
  }
  void createPart(){
    part1 = mCreator.createPartOne();
    part2 = mCreator.createPartTwo();
    part3 = mCreator.createPartThree();
  }
}

interface Creator{
  String createPartOne();
  String createPartTwo();
  String createPartThree();
}

class CreatorOne implements Creator{
  String createPartOne(){
    return "CreatorOne add part1";
  }
  String createPartTwo(){
    return "CreatorOne add part2";
  }
  String createPartThree(){
    return "CreatorOne add part3";
  }
}

class CreatorTwo implements Creator{
  String createPartOne(){
    return "CreatorTwo add part1";
  }
  String createPartTwo(){
    return "CreatorTwo add part2";
  }
  String createPartThree(){
    return "CreatorTwo add part3";
  }
}

void test(){
  //此时就要先实例化一个工厂对象，再根据type生产对象
  Product product;
  product = new ProductOne(new CreatorOne());
  product.createPart();
  product.output();
  product = new ProductOne(new CreatorTwo());
  product.createPart();
  product.output();
}
```

##### 实际应用
交通工具

注：存在例子不完全契合的情况
